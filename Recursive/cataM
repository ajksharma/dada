    let kArrow = ./../../caterwaul/Function/Kind

in  let kProduct = ./../../caterwaul/Tuple/Kind

in    λ(object : Kind)
    → λ(arrow : kArrow (kProduct object object) Type)
    → λ(category : ./../../caterwaul/Category/Type object arrow)
    →     let Endofunctor = ./../../caterwaul/Functor/Endo/Type object arrow
      
      in  let Monad = ./../../caterwaul/Monad/Type object arrow
      
      in  let Starfunctor =
                ./../../caterwaul/Functor/Endo/Star/Type object arrow
      
      in    λ(t : object)
          → λ(base : object → object)
          → λ(recursive : ./Type object arrow t base)
          → λ(m : kArrow object object)
          → λ(efunctor : Endofunctor m)
          → λ(monad : Monad m)
          → λ(sfunctor : Starfunctor m base)
          → λ(a : object)
          → λ(algebra : arrow { _1 = base a, _2 = m a })
          →     let Star/category =
                      ./../../caterwaul/Star/category
                      object
                      arrow
                      ( ./../../caterwaul/Category/extractSemigroupoid
                        object
                        arrow
                        category
                      )
                      m
                      efunctor
                      monad
            
            in  let Star/arrow = ./../../caterwaul/Star/Type object arrow m
            
            in  recursive.cata
                (m a)
                ( Star/category.op
                  { _1 = base (m a), _2 = a }
                  (   λ(r : Type)
                    → λ ( arrowsOut
                        :   ∀(z : object)
                          → Star/arrow { _1 = z, _2 = a }
                          → Star/arrow { _1 = base (m a), _2 = z }
                          → r
                        )
                    → arrowsOut
                      (base a)
                      algebra
                      ( ./../../caterwaul/Functor/Endo/Star/sequence
                        object
                        arrow
                        category
                        m
                        base
                        sfunctor
                        a
                      )
                  )
                )
