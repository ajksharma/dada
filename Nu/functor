    let Bifunctor =
          ./../../dhall-bhat/Functor/Bifunctor/Type
          Type
          ./../../dhall-bhat/Function/Type
          Type
          ./../../dhall-bhat/Function/Type
          Type
          ./../../dhall-bhat/Function/Type

in  let Bifunctor/terms =
          ./../../dhall-bhat/Functor/Bifunctor/terms.dhall
          Type
          ./../../dhall-bhat/Function/Type
          ./../../dhall-bhat/Function/category
          Type
          ./../../dhall-bhat/Function/Type
          ./../../dhall-bhat/Function/category
          Type
          ./../../dhall-bhat/Function/Type

in  let Functor = ./../../dhall-bhat/Functor/Endo/Set

in    λ(f : Type → Type → Type)
    → λ(functor : Bifunctor (λ(p : { _1 : Type, _2 : Type }) → f p._1 p._2))
    →     let bi =
                Bifunctor/terms
                (λ(p : { _1 : Type, _2 : Type }) → f p._1 p._2)
                functor
      
      in    { map =
                  λ(a : Type)
                → λ(b : Type)
                → λ(fn : a → b)
                → (./corecursive (f b)).ana
                  (./Type (f a))
                  (   λ(t : ./Type (f a))
                    → bi.first
                      (./Type (f a))
                      a
                      b
                      fn
                      ( (./steppable (f a) (bi.extractSecondFunctor a)).project
                        t
                      )
                  )
            }
          : Functor (λ(a : Type) → ./Type (f a))
