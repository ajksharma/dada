{- This variant of `cata` takes two structures (only the first of which must be
  `Recursive`) and folds over them simultaneously, much like a recursive
  `Applicative.op`.
-}
    let kArrow = ./../../dhall-bhat/Function/Kind

in  let object = Type

in  let cat = ./../../dhall-bhat/Category/Monoidal/Set/cartesian

in  let semigroupoid = ./../../dhall-bhat/Function/semigroupoid

in  let Day = ./../../dhall-bhat/Day/Type object cat cat

in    λ(t : object)
    → λ(f : kArrow object object)
    → λ(recursive : ./../Recursive/Type object cat.arrow t f)
    → λ(u : object)
    → λ(g : kArrow object object)
    → λ(steppable : ./../Steppable/Type object cat.arrow u g)
    → λ(a : object)
    → semigroupoid.op
      { _1 =
          cat.arrow { _1 = Day f g a, _2 = a }
      , _2 =
          cat.arrow { _1 = t, _2 = cat.arrow { _1 = u, _2 = a } }
      }
      (   λ(r : Type)
        → λ ( arrowsOut
            :   ∀(z : object)
              → (z → cat.arrow { _1 = t, _2 = cat.arrow { _1 = u, _2 = a } })
              → (cat.arrow { _1 = Day f g a, _2 = a } → z)
              → r
            )
        → arrowsOut
          ( cat.arrow
            { _1 =
                f (cat.arrow { _1 = u, _2 = a })
            , _2 =
                cat.arrow { _1 = u, _2 = a }
            }
          )
          (recursive.cata (cat.arrow { _1 = u, _2 = a }))
          (./../lowerDay f u g steppable a)
      )
